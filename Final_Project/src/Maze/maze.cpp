/**
* @file Maze.cpp
* @authors Group 4
*
* Karan Sutradhar (117037272)
* Sudharsan Balasubramani (116298636)
* Sai Bhamidipati (117023640)
* Ashwin Prabhakaran (117030402)
*
* @version 1.0
*
* @section LICENSE
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
*
* @section DESCRIPTION
*
*  This is the cpp for the class Maze, this is used to read maze files
*  generated by micro-mouse simulator
*/

#include "maze.h"
#include <vector>
#include "../API/api.h"

/**
 * @brief It updates the 'n','s','e','w' 2d array.
 * @param x
 * @param y
 * @param direction
 */
 void fp::Maze::ReadMaze(std::array<int, 2> curr_node, char direction) {
    int x{curr_node[0]},y{curr_node[1]};
    //std::cerr<<"\nRead Maze: "<<std::endl;
    if(direction == 'N'){
        if(API::wallFront()){
            //std::cerr<<"\t-Wall in Front"<<std::endl;
            API::setWall(y,15-x,'n');
            this->North_[x][y] = true;
        }
        if(API::wallRight()){
            //std::cerr<<"\t-Wall in Right"<<std::endl;
            API::setWall(y,15-x,'e');
            this->East_[x][y] = true;
        }
        if(API::wallLeft()){
            //std::cerr<<"\t-Wall in Left"<<std::endl;
            API::setWall(y,15-x,'w');
            this->West_[x][y] = true;
        }
    }
    if(direction == 'E'){
        if(API::wallFront()){
            //std::cerr<<"\t-Wall in Front"<<std::endl;
            API::setWall(y,15-x,'e');
            this->East_[x][y] = true;
        }
        if(API::wallRight()){
            //std::cerr<<"\t-Wall in Right"<<std::endl;
            API::setWall(y,15-x,'s');
            this->South_[x][y] = true;
        }
        if(API::wallLeft()){
            //std::cerr<<"\t-Wall in Left"<<std::endl;
            API::setWall(y,15-x,'n');
            this->North_[x][y] = true;
        }
    }
    if(direction == 'W'){
        if(API::wallFront()){
            //std::cerr<<"\t-Wall in Front"<<std::endl;
            API::setWall(y,15-x,'w');
            this->West_[x][y] = true;
        }
        if(API::wallRight()){
            //std::cerr<<"\t-Wall in Right"<<std::endl;
            API::setWall(y,15-x,'n');
            this->North_[x][y] = true;
        }
        if(API::wallLeft()){
            //std::cerr<<"\t-Wall in Left"<<std::endl;
            API::setWall(y,15-x,'s');
            this->South_[x][y] = true;
        }
    }
    if(direction == 'S'){
        if(API::wallFront()){
            //std::cerr<<"\t-Wall in Front"<<std::endl;
            API::setWall(y,15-x,'s');
            this->South_[x][y] = true;
        }
        if(API::wallRight()){
            //std::cerr<<"\t-Wall in Right"<<std::endl;
            API::setWall(y,15-x,'w');
            this->West_[x][y] = true;
        }
        if(API::wallLeft()){
            //std::cerr<<"\t-Wall in Left"<<std::endl;
            API::setWall(y,15-x,'e');
            this->East_[x][y] = true;
        }
    }

    //Mark the start nd goal position.
    fp::API::setColor(0,0,'G');
    fp::API::setText(0,0,"Start");
    fp::API::setColor(7,7,'G');
    fp::API::setText(7,7,"A");
    fp::API::setColor(7,8,'G');
    fp::API::setText(7,8,"G");
    fp::API::setColor(8,7,'G');
    fp::API::setText(8,7,"L");
    fp::API::setColor(8,8,'G');
    fp::API::setText(8,8,"O");
    
 }


/**
 * @brief Adds color to the tiles of the maze grid.
 * @param &X
 * @param &Y
 */
void fp::Maze::ColorPath(std::array<int,2> node) {
    API::setColor(node[1],15-node[0],'y'); //Sets color to the path x,y as yellow by calling the API function.
}
